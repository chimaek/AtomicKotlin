## 예외 처리 (#2)

시작 코드에서는 예외 계층 구조와 세 가지 함수를 정의합니다:

- `findNumber(s: String)`은 `s`에서 숫자를 검색해 숫자가 포함된 `String`을 반환합니다. 숫자를 찾을 수 없으면 `NoNumber` 예외를 발생시킵니다.

- `convertNumber(s: String)`은 `s`를 `Int`로 변환합니다. `s`가 `Int`로 변환될 수 없을 경우 `BadNumber` 예외를 발생시킵니다.

- `embedNumber(n: Int)`는 `n`을 일부 문자 내에 포함하는 `String`을 생성합니다.

당신의 작업은 두 가지 함수를 정의하는 것입니다:

- `justFail(s: String)`은 위의 세 가지 함수를 호출하며 함수 호출을 중첩합니다. `String`에서 숫자를 찾아 이를 `Int`로 변환하고, 그 `Int`를 `String` 안에 포함한 후 결과를 가지고 `trace()`를 호출합니다.

- `recover(s: String)`은 위의 각 함수를 한 번에 하나씩 호출하며, 각 호출에 대한 실패를 복구하여 다음 호출이 성공할 수 있도록 합니다. 만약 `findNumber()`가 실패하면 복구는 `"0"`이라는 `String`을 생성합니다. 만약 `convertNumber()`가 실패하면 복구는 `-1`을 생성합니다. `recover()`의 끝에서 결과를 가지고 `trace()`를 호출합니다.

나머지 시작 코드는 위의 두 함수를 테스트합니다.

예외로 인해 발생할 수 있는 잠재적 효과를 주의하세요:

1. 함수가 하나 이상의 예외를 발생시킬 수 있다면, 해당 함수 호출은 상당히 복잡해질 수 있습니다.

2. 복구라는 개념은 실패한 함수 호출에서 복구할 *방법*이 존재한다는 전제를 가집니다. 하지만, 이는 자주 사실이 아닙니다.

<sub> 이 작업은 자동 테스트가 포함되어 있지 않으므로, "체크"를 실행할 때 항상 "Correct"로 표시됩니다. 제공된 솔루션과 당신의 솔루션을 비교해보세요! </sub>