## 리소스 정리 (#3)

이 연습의 목표는 `use()` 블록을 종료하는 방식에 상관없이 항상 `close()` 함수가 호출되도록 코드를 확인하는 것입니다. 연습문제 2에서 생성한 `Cleanup` 클래스를 재사용하며, 초기 코드에 포함되어 있는 `enum class Option { Normal, Return, Throw }`와 함께 사용합니다.

`verifyClose(opt: Option)` 함수를 정의하세요. `verifyClose()`는 `Cleanup` 객체를 생성하고 해당 객체에서 `use()`를 호출합니다. `use()`의 람다 본문에는 `when` 표현식을 사용하여 다음 규칙을 구현합니다. `opt`가 다음과 같을 때:

- `Normal`: `f()`가 호출되고, `g()` (`when` 표현식 내에서) 호출된 후 `h()`가 호출되며, 그 후 `use()` 블록을 빠져나갑니다.

- `Return`: `f()`가 호출된 후 `return`이 실행됩니다. 이는 `use()` 블록 중간에서 종료됩니다.

- `Throw`: `f()`가 호출된 후 `Exception`이 `use()` 블록 중간에서 던져집니다.

`main()`에서 작성한 코드를 테스트하세요.

<sub> 이 과제는 자동 테스트를 포함하지 않습니다.
따라서 "Check"를 실행하면 항상 "Correct"로 표시됩니다.
제공된 해결 방법과 비교하여 본인의 해결 방법을 확인하세요! </sub>